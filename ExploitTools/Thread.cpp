#include "Tools.h"
#include <chrono>
#include <thread>

// various tools used to interact with thread objects
namespace Thread
{
	// stores the 64 bit thread redirection shell code
	byte ShellCode64[100] = {
		0x48, 0x83, 0xEC, 0x08, 0xC7, 0x04, 0x24, 0xCC, 0xCC, 0xCC, 0xCC, 0xC7, 0x44, 0x24, 0x04, 0xCC,
		0xCC, 0xCC, 0xCC, 0x50, 0x53, 0x51, 0x52, 0x57, 0x56, 0x54, 0x55, 0x41, 0x50, 0x41, 0x51, 0x41,
		0x52, 0x41, 0x53, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x9C, 0x48, 0xB8, 0xBB, 0xBB,
		0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0x48, 0xB9, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x83, 0xEC, 0x10, 0xFF, 0xD0, 0x48, 0x83, 0xC4, 0x10, 0x9D, 0x41, 0x5F, 0x41, 0x5E, 0x41,
		0x5D, 0x41, 0x5C, 0x41, 0x5B, 0x41, 0x5A, 0x41, 0x59, 0x41, 0x58, 0x5D, 0x5C, 0x5E, 0x5F, 0x5A,
		0x59, 0x5B, 0x58, 0xC3
	};

	// stores the 32 bit thread redirection shell code
	byte ShellCode32[23] = {
		0x68, 0xCC, 0xCC, 0xCC, 0xCC, 0x60, 0x9C, 0xB8, 0xBB, 0xBB, 0xBB, 0xBB, 0x68, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xFF, 0xD0, 0x9D, 0x61, 0xC3
	};

	// stores the 64 bit thread redirection shell code
	byte EntryShellCode64[120] = {
		0x48, 0x83, 0xEC, 0x08, 0xC7, 0x04, 0x24, 0xCC, 0xCC, 0xCC, 0xCC, 0xC7, 0x44, 0x24, 0x04, 0xCC,
		0xCC, 0xCC, 0xCC, 0x50, 0x53, 0x51, 0x52, 0x57, 0x56, 0x54, 0x55, 0x41, 0x50, 0x41, 0x51, 0x41,
		0x52, 0x41, 0x53, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x9C, 0x48, 0xB8, 0xBB, 0xBB,
		0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0x48, 0xB9, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0xBA, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x49, 0xB8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x83, 0xEC, 0x20, 0xFF, 0xD0, 0x48, 0x83, 0xC4, 0x20, 0x9D, 0x41, 0x5F, 0x41, 0x5E, 0x41,
		0x5D, 0x41, 0x5C, 0x41, 0x5B, 0x41, 0x5A, 0x41, 0x59, 0x41, 0x58, 0x5D, 0x5C, 0x5E, 0x5F, 0x5A,
		0x59, 0x5B, 0x58, 0xC3
	};

	// stores the 32 bit thread redirection shell code
	byte EntryShellCode32[32] = {
		0x68, 0xCC, 0xCC, 0xCC, 0xCC, 0x60, 0x9C, 0xB8, 0xBB, 0xBB, 0xBB, 0xBB, 0x68, 0xCC, 0xCC, 0xCC,
		0xCC, 0x68, 0xCC, 0xCC, 0xCC, 0xCC, 0x68, 0xCC, 0xCC, 0xCC, 0xCC, 0xFF, 0xD0, 0x9D, 0x61, 0xC3
	};

	// opens a handle to the given thread via a driver
	HANDLE GetThreadHandle(DWORD dwThreadId, DWORD dwDesiredAccess)
	{
		// opens a handle to the thread
		HANDLE hThread = OpenThread(dwDesiredAccess, FALSE, dwThreadId);
		// validates the handle
		if (hThread != INVALID_HANDLE_VALUE)
			// check if the handle value is correct
			// if not elevate
			// do this!
			// elevates the created handle
			// if (Process::SetHandleAccess(hThread, dwDesiredAccess))
			// returns the handle
			return hThread;
		// function failed
		return NULL;
	}

	// returns an arbitrary thread id from the process
	DWORD GetProcessThread(DWORD dwProcessId)
	{
		// takes a snapshot of all current system threads
		HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, dwProcessId);
		// checks the handle
		if (snapshot != INVALID_HANDLE_VALUE)
		{
			// stores information about our thread
			THREADENTRY32 threadInfo;
			// initalizes our threadInfo structure
			threadInfo.dwSize = sizeof(THREADENTRY32);
			// gets the first thread
			if (Thread32First(snapshot, &threadInfo))
			{
				// iterates through all threads
				do
				{
					// checks the process id
					if (threadInfo.th32OwnerProcessID == dwProcessId)
					{
						// returns the thread id
						return threadInfo.th32ThreadID;
					}
				} while (Thread32Next(snapshot, &threadInfo));
			}
		}
		// else we return null
		return NULL;
	}

	// redirects a the thread associated with the given thread handle (64 bit processes only)
	BOOL RedirectThread64(HANDLE hProcess, HANDLE hThread, PVOID pAddress, PVOID pArgument)
	{
		// allocates executable memory for the shellcode
		LPVOID ShellCodeAddress = VirtualAllocEx(hProcess, NULL, sizeof(ShellCode64), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
		// validates address
		if (ShellCodeAddress)
		{
			// suspends the thread
			if (SuspendThread(hThread) != -1)
			{
				// notifies user
				// cout << "Suspended thread: 0x" << hex << ThreadHandle << endl;
				// stores our thread context
				CONTEXT ctx;
				// we want the full context
				ctx.ContextFlags = CONTEXT_FULL;
				// gets the thread context
				if (GetThreadContext(hThread, &ctx))
				{
					// writes the old eip to the shell code
					*(DWORD*)&ShellCode64[0x7] = LODWORD(ctx.Rip);
					*(DWORD*)&ShellCode64[0xF] = HIDWORD(ctx.Rip);
					// writes the address of load library
					*(DWORD64*)&ShellCode64[0x2E] = (DWORD64)pAddress;
					// writes the addrs of the dll string
					*(DWORD64*)&ShellCode64[0x38] = (DWORD64)pArgument;
					// writes shellcode to the buffer
					if (WriteProcessMemory(hProcess, ShellCodeAddress, ShellCode64, sizeof(ShellCode64), NULL))
					{
						// notifies user
						// cout << "Shell code written to: 0x" << hex << ShellCodeAddress << endl;
						// sets the instruction pointer to point to the shell code
						ctx.Rip = (DWORD64)ShellCodeAddress;
						// applies the thread context
						if (SetThreadContext(hThread, &ctx))
						{
							// resumes the thread
							if (ResumeThread(hThread) != -1)
							{
								// notifies user
								// cout << "Resumed thread: 0x" << hex << ThreadHandle << endl;
								// returns true
								return TRUE;
							}
						}
					}
				}
			}
		}
		// returns false
		return FALSE;
	}

	// redirects a the thread associated with the given thread handle (32 bit processes only)
	BOOL RedirectThread32(HANDLE hProcess, HANDLE hThread, PVOID pAddress, PVOID pArgument)
	{
		// allocates executable memory for the shellcode
		LPVOID ShellCodeAddress = VirtualAllocEx(hProcess, NULL, sizeof(ShellCode32), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
		// validates address
		if (ShellCodeAddress)
		{
			// suspends the thread
			if (Wow64SuspendThread(hThread) != -1)
			{
				// notifies user
				// cout << "Suspended thread: 0x" << hex << ThreadHandle << endl;
				// stores our thread context
				WOW64_CONTEXT ctx;
				// we want the full context
				ctx.ContextFlags = WOW64_CONTEXT_FULL;
				// gets the thread context
				if (Wow64GetThreadContext(hThread, &ctx))
				{
					// writes the old eip to the shell code
					*(DWORD*)&ShellCode32[0x1] = ctx.Eip;
					// writes the address of load library
					*(DWORD*)&ShellCode32[0x8] = (DWORD)pAddress;
					// writes the addrs of the dll string
					*(DWORD*)&ShellCode32[0xD] = (DWORD)pArgument;
					// writes shellcode to the buffer
					if (WriteProcessMemory(hProcess, ShellCodeAddress, ShellCode32, sizeof(ShellCode32), NULL))
					{
						// notifies user
						// cout << "Shell code written to: 0x" << hex << ShellCodeAddress << endl;
						// sets the instruction pointer to point to the shell code
						ctx.Eip = (DWORD)ShellCodeAddress;
						// applies the thread context
						if (Wow64SetThreadContext(hThread, &ctx))
						{
							// resumes the thread
							if (ResumeThread(hThread) != -1)
							{
								// notifies user
								// cout << "Resumed thread: 0x" << hex << ThreadHandle << endl;
								// returns true
								return TRUE;
							}
						}
					}
				}
			}
		}
		// returns false
		return FALSE;
	}

	// redirects a the thread associated with the given thread handle (universal wrapper)
	BOOL RedirectThread(HANDLE hProcess, HANDLE hThread, PVOID pAddress, PVOID pArgument)
	{
		// stores the result
		BOOL IsWow64;
		// checks the if the target process is 32 bit
		if (Process::IsProcess32(hProcess, &IsWow64))
			// checks if the process is 32 bit
			if (IsWow64)
				// returns the result
				return RedirectThread32(hProcess, hThread, pAddress, pArgument);
			else
				// returns the result
				return RedirectThread64(hProcess, hThread, pAddress, pArgument);
		// returns false
		return FALSE;
	}

	// calls the specified image entry point (64 bit processes only)
	BOOL CallEntry64(HANDLE hProcess, PVOID pEntry, HINSTANCE hinstDLL, DWORD fdwReason)
	{
		// gets a random thread
		if (DWORD dwThreadId = GetProcessThread(GetProcessId(hProcess)))
		{
			// opens a handle to the thread
			if (HANDLE hThread = GetThreadHandle(dwThreadId, THREAD_ALL_ACCESS))
			{
				// allocates executable memory for the shellcode
				LPVOID ShellCodeAddress = VirtualAllocEx(hProcess, NULL, sizeof(EntryShellCode64), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
				// validates address
				if (ShellCodeAddress)
				{
					// suspends the thread
					if (SuspendThread(hThread) != -1)
					{
						// stores our thread context
						CONTEXT ctx;
						// we want the full context
						ctx.ContextFlags = CONTEXT_FULL;
						// gets the thread context
						if (GetThreadContext(hThread, &ctx))
						{
							// writes the old eip to the shell code
							*(DWORD*)&EntryShellCode64[0x7] = LODWORD(ctx.Rip);
							*(DWORD*)&EntryShellCode64[0xF] = HIDWORD(ctx.Rip);
							// writes the address of load library
							*(DWORD64*)&EntryShellCode64[0x2E] = (DWORD64)pEntry;
							// writes the addrs of the dll string
							*(DWORD64*)&EntryShellCode64[0x38] = (DWORD64)hinstDLL;
							// writes the addrs of the dll string
							*(DWORD64*)&EntryShellCode64[0x42] = (DWORD64)fdwReason;
							// writes shellcode to the buffer
							if (WriteProcessMemory(hProcess, ShellCodeAddress, EntryShellCode64, sizeof(EntryShellCode64), NULL))
							{
								// sets the instruction pointer to point to the shell code
								ctx.Rip = (DWORD64)ShellCodeAddress;
								// applies the thread context
								if (SetThreadContext(hThread, &ctx))
								{
									//std::cout << ShellCodeAddress << std::endl;
									//std::cin.get();
									// resumes the thread
									if (ResumeThread(hThread) != -1)
									{
										std::this_thread::sleep_for(std::chrono::seconds(5));
										// returns true
										return TRUE;
									}
								}
							}
						}
					}
				}
			}
		}
		// returns false
		return FALSE;
	}

	// calls the specified image entry point (32 bit processes only)
	BOOL CallEntry32(HANDLE hProcess, PVOID pEntry, HINSTANCE hinstDLL, DWORD fdwReason)
	{
		// gets a random thread
		if (DWORD dwThreadId = GetProcessThread(GetProcessId(hProcess)))
		{
			// opens a handle to the thread
			if (HANDLE hThread = GetThreadHandle(dwThreadId, THREAD_ALL_ACCESS))
			{
				// allocates executable memory for the shellcode
				LPVOID ShellCodeAddress = VirtualAllocEx(hProcess, NULL, sizeof(EntryShellCode32), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
				// validates address
				if (ShellCodeAddress)
				{
					// suspends the thread
					if (Wow64SuspendThread(hThread) != -1)
					{
						// stores our thread context
						WOW64_CONTEXT ctx;
						// we want the full context
						ctx.ContextFlags = WOW64_CONTEXT_FULL;
						// gets the thread context
						if (Wow64GetThreadContext(hThread, &ctx))
						{
							// writes the old eip to the shell code
							*(DWORD*)&EntryShellCode32[1] = ctx.Eip;
							// writes the address of load library
							*(DWORD*)&EntryShellCode32[8] = (DWORD)pEntry;
							// writes the module handle
							*(DWORD*)&EntryShellCode32[18] = (DWORD)fdwReason;
							// writes the module handle
							*(DWORD*)&EntryShellCode32[23] = (DWORD)hinstDLL;
							// writes shellcode to the buffer
							if (WriteProcessMemory(hProcess, ShellCodeAddress, EntryShellCode32, sizeof(EntryShellCode32), NULL))
							{
								// sets the instruction pointer to point to the shell code
								ctx.Eip = (DWORD)ShellCodeAddress;
								// applies the thread context
								if (Wow64SetThreadContext(hThread, &ctx))
								{
									// resumes the thread
									if (ResumeThread(hThread) != -1)
									{
										std::this_thread::sleep_for(std::chrono::seconds(5));
										// returns true
										return TRUE;
									}
								}
							}
						}
					}
				}
			}
		}
		// returns false
		return FALSE;
	}

	// calls the specified image entry point (universal wrapper)
	BOOL CallEntry(HANDLE hProcess, PVOID pEntry, HINSTANCE hinstDLL, DWORD fdwReason)
	{
		// stores the result
		BOOL IsWow64;
		// checks the if the target process is 32 bit
		if (Process::IsProcess32(hProcess, &IsWow64))
			// checks if the process is 32 bit
			if (IsWow64)
				// returns the result
				return CallEntry32(hProcess, pEntry, hinstDLL, fdwReason);
			else
				// returns the result
				return CallEntry64(hProcess, pEntry, hinstDLL, fdwReason);
		// returns false
		return FALSE;
	}
}