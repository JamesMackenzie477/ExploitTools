#include "Tools.h"
#include <list>

/*class Process
{
	// Attach();
	// GetModuleHandle();
};*/

// various tools used to interact with process modules
namespace Module
{
	typedef struct _MODULE
	{
		const char * name;
		HMODULE handle;

		_MODULE(const char * name, HMODULE handle)
			: name(name), handle(handle)
		{

		}
	} MODULE, *PMODULE;

	std::list<MODULE> modules;

	// Returns the resolved function address from a C runtime module.
	char * ResolveCrtModule64(HANDLE procHandle, std::string moduleName, char * functionAddress)
	{
		// if (moduleName.find("crt") != std::string::npos)
		// {
		/*

		If the module is part of the C runtime then we need to read the module name
		and function name that this C runtime module maps it's function to, then load the
		specified module and retrieve the function address.

		*/

		char moduleAndFunction[MAX_PATH];
		if (!ReadProcessMemory(procHandle, functionAddress, moduleAndFunction, sizeof(moduleAndFunction), nullptr)) return false;
		std::string modAndFunc(moduleAndFunction);
		// GROSS IK.
		if (modAndFunc.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890_-.") == std::string::npos)
		{
			auto pos = modAndFunc.find(".");

			std::string modName(modAndFunc.substr(0, pos) + ".dll");
			std::string funcName(modAndFunc.substr(pos + 1));

			if (/*modName == "ucrtbase.dll"*/true)
			{
				auto modHandle = LoadRemoteLibrary(procHandle, File::FindImagePath64(ResolveApiModule(modName.c_str())));

				if (modHandle) return reinterpret_cast<char *>(GetRemoteProcAddress(procHandle, modHandle, funcName.c_str()));
			}
			else
			{
				auto modHandle = LoadRemoteImage(procHandle, File::FindImagePath64(ResolveApiModule(modName.c_str())));

				if (modHandle) return reinterpret_cast<char *>(GetRemoteProcAddress(procHandle, modHandle, funcName.c_str()));
			}
		}
		// }
		return functionAddress;
	}

	// Returns the resolved function address from a C runtime module.
	char * ResolveCrtModule32(HANDLE procHandle, std::string moduleName, char * functionAddress)
	{
		// if (moduleName.find("crt") != std::string::npos)
		// {
		/*

		If the module is part of the C runtime then we need to read the module name
		and function name that this C runtime module maps it's function to, then load the
		specified module and retrieve the function address.

		*/

		char moduleAndFunction[MAX_PATH];
		if (!ReadProcessMemory(procHandle, functionAddress, moduleAndFunction, sizeof(moduleAndFunction), nullptr)) return false;
		std::string modAndFunc(moduleAndFunction);
		// GROSS IK.
		if (modAndFunc.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890_-.") == std::string::npos)
		{
			auto pos = modAndFunc.find(".");

			std::string modName(modAndFunc.substr(0, pos) + ".dll");
			std::string funcName(modAndFunc.substr(pos + 1));

			if (/*modName == "ucrtbase.dll"*/true)
			{
				auto modHandle = LoadRemoteLibrary(procHandle, File::FindImagePath32(ResolveApiModule(modName.c_str())));

				if (modHandle) return reinterpret_cast<char *>(GetRemoteProcAddress(procHandle, modHandle, funcName.c_str()));
			}
			else
			{
				auto modHandle = LoadRemoteImage(procHandle, File::FindImagePath32(ResolveApiModule(modName.c_str())));

				if (modHandle) return reinterpret_cast<char *>(GetRemoteProcAddress(procHandle, modHandle, funcName.c_str()));
			}
		}
		// }
		return functionAddress;
	}

	// resolves an api dll to the dll it referances
	LPCSTR ResolveApiModule(LPCSTR lpApiModuleName)
	{
		// converts it to a char string
		std::string sApiModuleName = std::string(lpApiModuleName);
		// converts it to a wchar string
		std::wstring wsApiModuleName = std::wstring(sApiModuleName.begin(), sApiModuleName.end());
		// gets the process environment block
		PPROCENVBLOCK pProcEnvBlock = (PPROCENVBLOCK)NtCurrentTeb()->ProcessEnvironmentBlock;
		// gets the api set map address
		PAPISETMAP pApiSetMap = pProcEnvBlock->ApiSetMap;
		// gets the dll host descriptor array
		PDLLHOSTDESCRIPTOR pDllHostDescriptor = pApiSetMap->descriptors;
		// iterates through the dll host descriptors
		for (int i = 0; i < pApiSetMap->NumberOfHosts; i++)
		{
			// validates the api dll name
			if (_wcsnicmp((LPWSTR)((DWORD64)pApiSetMap + pDllHostDescriptor[i].OffsetDllString), wsApiModuleName.substr(4, wsApiModuleName.length() - 8).c_str(), wsApiModuleName.length()) == 0)
			{
				// gets the dll redirector array
				PDLLREDIRECTOR pDllRedirector = (PDLLREDIRECTOR)((DWORD64)pApiSetMap + pDllHostDescriptor[i].OffsetDllRedirector);
				// converts it to a wchar string
				std::wstring wsResolveModuleName = std::wstring((LPWSTR)((DWORD64)pApiSetMap + pDllRedirector->Redirection->OffsetRedirection2), pDllRedirector->Redirection->RedirectionLength2 / 2);
				// converts it to a char string
				std::string* sResolveModuleName = new std::string(wsResolveModuleName.begin(), wsResolveModuleName.end());
				// creates a buffer to send back
				// LPCSTR lpResolvedName = new CHAR[sResolveModuleName.length() + 1];
				// adds the string to the buffer
				// memcpy(&lpResolvedName, sResolveModuleName.c_str(), sResolveModuleName.length());
				// null teminates the string
				// lpResolvedName[sResolveModuleName.length()] = 0;
				// returns the resolved dll name
				return sResolveModuleName->c_str();
			}
		}
		// else we return null
		return lpApiModuleName;
	}

	// returns the nt headers of the specified module (64 bit processes only)
	PIMAGE_NT_HEADERS64 ReadNtHeaders64(HANDLE hProcess, HMODULE hModule)
	{
		// stores the image dos headers
		IMAGE_DOS_HEADER DosHeader;
		// reads the dos headers of the module
		if (ReadProcessMemory(hProcess, hModule, &DosHeader, sizeof(IMAGE_DOS_HEADER), NULL))
		{
			// stores the image nt headers
			PIMAGE_NT_HEADERS64 NtHeaders = new IMAGE_NT_HEADERS64();
			// reads the nt headers of the module
			if (ReadProcessMemory(hProcess, (PVOID)((DWORD64)hModule + DosHeader.e_lfanew), NtHeaders, sizeof(IMAGE_NT_HEADERS64), NULL))
			{
				// returns the nt headers
				return NtHeaders;
			}
		}
		// function failed
		return NULL;
	}

	// returns the nt headers of the specified module (32 bit processes only)
	PIMAGE_NT_HEADERS32 ReadNtHeaders32(HANDLE hProcess, HMODULE hModule)
	{
		// stores the image dos headers
		IMAGE_DOS_HEADER DosHeader;
		// reads the dos headers of the module
		if (ReadProcessMemory(hProcess, hModule, &DosHeader, sizeof(IMAGE_DOS_HEADER), NULL))
		{
			// stores the image nt headers
			PIMAGE_NT_HEADERS32 NtHeaders = new IMAGE_NT_HEADERS32();
			// reads the nt headers of the module
			if (ReadProcessMemory(hProcess, (PVOID)((DWORD64)hModule + DosHeader.e_lfanew), NtHeaders, sizeof(IMAGE_NT_HEADERS32), NULL))
			{
				// returns the nt headers
				return NtHeaders;
			}
		}
		// function failed
		return NULL;
	}

	// reads the specified directory of the given module (64 bit processes only)
	PVOID ReadDirectory64(HANDLE hProcess, HMODULE hModule, DWORD dwDirectory, PDWORD dwOut)
	{
		// reads the nt headers of the module
		if (PIMAGE_NT_HEADERS64 pNtHeaders = ReadNtHeaders64(hProcess, hModule))
		{
			// gets the directory
			IMAGE_DATA_DIRECTORY Directory = pNtHeaders->OptionalHeader.DataDirectory[dwDirectory];
			// ensures the directory exists
			if (Directory.VirtualAddress && Directory.Size)
			{
				// gets the directory address
				PVOID pAddress = (PVOID)((DWORD64)hModule + Directory.VirtualAddress);
				// gets the directory size
				DWORD dwSize = Directory.Size;
				// creates a buffer for the directory
				PVOID pDirectory = malloc(dwSize);
				// reads the directory into the buffer
				if (ReadProcessMemory(hProcess, pAddress, pDirectory, dwSize, NULL))
				{
					// frees the headers buffer
					free(pNtHeaders);
					// sets the output size
					*dwOut = dwSize;
					// returns the directory
					return pDirectory;
				}
			}
			// frees the headers buffer
			free(pNtHeaders);
		}
		// function failed
		return NULL;
	}

	// reads the specified directory of the given module (32 bit processes only)
	PVOID ReadDirectory32(HANDLE hProcess, HMODULE hModule, DWORD dwDirectory, PDWORD dwOut)
	{
		// reads the nt headers of the module
		if (PIMAGE_NT_HEADERS32 pNtHeaders = ReadNtHeaders32(hProcess, hModule))
		{
			// gets the directory
			IMAGE_DATA_DIRECTORY Directory = pNtHeaders->OptionalHeader.DataDirectory[dwDirectory];
			// ensures the directory exists
			if (Directory.VirtualAddress && Directory.Size)
			{
				// gets the directory address
				PVOID pAddress = (PVOID)((DWORD64)hModule + Directory.VirtualAddress);
				// gets the directory size
				DWORD dwSize = Directory.Size;
				// creates a buffer for the directory
				PVOID pDirectory = malloc(dwSize);
				// reads the directory into the buffer
				if (ReadProcessMemory(hProcess, pAddress, pDirectory, dwSize, NULL))
				{
					// frees the headers buffer
					free(pNtHeaders);
					// sets the output size
					*dwOut = dwSize;
					// returns the directory
					return pDirectory;
				}
			}
			// frees the headers buffer
			free(pNtHeaders);
		}
		// function failed
		return NULL;
	}

	// reads the specified directory of the given module (universal wrapper)
	PVOID ReadDirectory(HANDLE hProcess, HMODULE hModule, DWORD dwDirectory, PDWORD dwOut)
	{
		// stores the result
		BOOL IsWow64;
		// checks the if the target process is 32 bit
		if (Process::IsProcess32(hProcess, &IsWow64))
			// checks if the process is 32 bit
			if (IsWow64)
				// returns the result
				return ReadDirectory32(hProcess, hModule, dwDirectory, dwOut);
			else
				// returns the result
				return ReadDirectory64(hProcess, hModule, dwDirectory, dwOut);
		// function failed
		return NULL;
	}

	// returns the base address of the module in the given process
	PVOID GetModuleBaseSnapshot32(DWORD dwProcessId, LPCSTR lpModuleName)
	{
		// enables the debug priviliage
		Process::SetDebugPrivilege(GetCurrentProcess(), TRUE);
		// takes a snapshot of all current process modules
		HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, dwProcessId);
		// checks the handle
		if (snapshot != INVALID_HANDLE_VALUE)
		{
			// stores information about our module
			MODULEENTRY32 moduleInfo;
			// initalizes our threadInfo structure
			moduleInfo.dwSize = sizeof(MODULEENTRY32);
			// gets the first module
			if (Module32First(snapshot, &moduleInfo))
			{
				// iterates through all modules
				do
				{
					// checks the module name
					if (_stricmp(moduleInfo.szModule, lpModuleName) == 0)
					{
						// returns the module base
						return moduleInfo.modBaseAddr;
						// disables the debug priviliage
						Process::SetDebugPrivilege(GetCurrentProcess(), FALSE);
					}
				} while (Module32Next(snapshot, &moduleInfo));
			}
		}
		// disables the debug priviliage
		Process::SetDebugPrivilege(GetCurrentProcess(), FALSE);
		// else we return null
		return NULL;
	}

	// returns the base address of the module in the given process
	HMODULE GetRemoteModuleHandle(HANDLE hProcess, LPCSTR lpModuleName)
	{
		// stores the modules
		HMODULE hModules[1024];
		// stores the needed bytes
		DWORD NeededBytes;
		// gets an array of module handles
		if (EnumProcessModulesEx(hProcess, hModules, sizeof(hModules), &NeededBytes, LIST_MODULES_ALL))
		{
			// iterates through module handles
			for (int i = 0; i < NeededBytes / sizeof(HMODULE); i++)
			{
				// stores the module image name
				CHAR BaseName[MAX_PATH];
				// gets the name of the module
				if (GetModuleBaseName(hProcess, hModules[i], BaseName, MAX_PATH))
				{
					// compares the names
					if (_stricmp(BaseName, lpModuleName) == 0)
					{
						// returns the base address
						return hModules[i];
					}
				}
			}
		}

		// Checks the mapped modules.
		for (const MODULE& module : modules)
		{
			if (_stricmp(module.name, lpModuleName) == 0)
			{
				return module.handle;
			}
		}

		// else we return null
		return NULL;
	}

	// maps the specified image to the remote process (64 bit processes only)
	HMODULE RemoteMapImage64(HANDLE hProcess, LPCSTR lpImagePath)
	{
		// stores the image size
		DWORD dwSize;
		// reads the image
		if (PVOID pImage = File::ReadA(lpImagePath, &dwSize))
		{
			// gets the dos headers of the dll
			PIMAGE_DOS_HEADER pDosHeaders = (PIMAGE_DOS_HEADER)pImage;
			// gets the nt headers of the dll
			PIMAGE_NT_HEADERS64 pNtHeaders = (PIMAGE_NT_HEADERS64)((DWORD64)pImage + pDosHeaders->e_lfanew);
			// validates the module is 64 bit
			// if (pNtHeaders->OptionalHeader.Magic == PE64)
			// {
			// allocates memory in the process for the dll
			PVOID pBase = VirtualAllocEx(hProcess, NULL, pNtHeaders->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
			// checks if the memory allocation succeeded
			if (pBase)
			{
				// writes the headers to the process
				if (WriteProcessMemory(hProcess, pBase, pImage, pNtHeaders->OptionalHeader.SizeOfHeaders, NULL))
				{
					// writes the sections to the process
					// gets the first section header
					PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRST_SECTION(pNtHeaders);
					// iterates through the sections
					for (INT i = 0; i < pNtHeaders->FileHeader.NumberOfSections; i++)
					{
						// writes the section to the process
						if (!WriteProcessMemory(hProcess, (PVOID)((DWORD64)pBase + pSectionHeader[i].VirtualAddress), (PVOID)((DWORD64)pImage + pSectionHeader[i].PointerToRawData), pSectionHeader[i].SizeOfRawData, NULL))
						{
							// frees the buffer
							free(pImage);
							// frees the memory in the process
							VirtualFreeEx(hProcess, pBase, 0, MEM_RELEASE);
							// else we return null
							return NULL;
						}
					}
					// sets the number of bytes written
					// *lpNumberOfBytesWritten = pNtHeaders->OptionalHeader.SizeOfImage;
					// frees the buffer
					free(pImage);
					// returns the module handle
					return (HMODULE)pBase;
				}
				// frees the memory in the process
				VirtualFreeEx(hProcess, pBase, 0, MEM_RELEASE);
			}
			// }
			// frees the buffer
			free(pImage);
		}
		// function failed
		return FALSE;
	}

	// maps the specified image to the remote process (32 bit processes only)
	HMODULE RemoteMapImage32(HANDLE hProcess, LPCSTR lpImagePath)
	{
		// stores the image size
		DWORD dwSize;
		// reads the image
		if (PVOID pImage = File::ReadA(lpImagePath, &dwSize))
		{
			// gets the dos headers of the dll
			PIMAGE_DOS_HEADER pDosHeaders = (PIMAGE_DOS_HEADER)pImage;
			// gets the nt headers of the dll
			PIMAGE_NT_HEADERS32 pNtHeaders = (PIMAGE_NT_HEADERS32)((DWORD64)pImage + pDosHeaders->e_lfanew);
			// validates the module is 32 bit
			// if (pNtHeaders->OptionalHeader.Magic == PE32)
			// {
			// allocates memory in the process for the dll
			PVOID pBase = VirtualAllocEx(hProcess, NULL, pNtHeaders->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
			// checks if the memory allocation succeeded
			if (pBase)
			{
				// writes the headers to the process
				if (WriteProcessMemory(hProcess, pBase, pImage, pNtHeaders->OptionalHeader.SizeOfHeaders, NULL))
				{
					// writes the sections to the process
					// gets the first section header
					PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRST_SECTION(pNtHeaders);
					// iterates through the sections
					for (INT i = 0; i < pNtHeaders->FileHeader.NumberOfSections; i++)
					{
						// writes the section to the process
						if (!WriteProcessMemory(hProcess, (PVOID)((DWORD64)pBase + pSectionHeader[i].VirtualAddress), (PVOID)((DWORD64)pImage + pSectionHeader[i].PointerToRawData), pSectionHeader[i].SizeOfRawData, NULL))
						{
							// frees the buffer
							free(pImage);
							// frees the memory in the process
							VirtualFreeEx(hProcess, pBase, 0, MEM_RELEASE);
							// else we return null
							return NULL;
						}
					}
					// sets the number of bytes written
					// *lpNumberOfBytesWritten = pNtHeaders->OptionalHeader.SizeOfImage;
					// frees the buffer
					free(pImage);
					// returns the module handle
					return (HMODULE)pBase;
				}
				// frees the memory in the process
				VirtualFreeEx(hProcess, pBase, 0, MEM_RELEASE);
			}
			// }
			// frees the buffer
			free(pImage);
		}
		// function failed
		return FALSE;
	}

	// maps the specified image to the remote process (universal wrapper)
	HMODULE RemoteMapImage(HANDLE hProcess, LPCSTR lpImagePath)
	{
		// stores the result
		BOOL IsWow64;
		// checks the if the target process is 32 bit
		if (Process::IsProcess32(hProcess, &IsWow64))
			// checks if the process is 32 bit
			if (IsWow64)
				// returns the result
				return RemoteMapImage32(hProcess, lpImagePath);
			else
				// returns the result
				return RemoteMapImage64(hProcess, lpImagePath);
		// function failed
		return NULL;
	}

	// rebases the specified remote image (64 bit processes only)
	BOOL RemoteRebaseImage64(HANDLE hProcess, HMODULE hModule)
	{
		// reads the nt headers of the module
		if (PIMAGE_NT_HEADERS64 pNtHeaders = ReadNtHeaders64(hProcess, hModule))
		{
			// if the base relocation directory exists
			if (pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress)
			{
				// stores the base relocation directory
				PVOID pBaseRelocation = malloc(pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
				// reads the base relocation directory of the module
				if (ReadProcessMemory(hProcess, (PVOID)((DWORD64)hModule + pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress), pBaseRelocation, pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size, NULL))
				{
					// casts the buffer
					PIMAGE_BASE_RELOCATION BaseRelocationBlock = (PIMAGE_BASE_RELOCATION)pBaseRelocation;
					// calculates ending address
					PVOID EndAddress = (PVOID)((DWORD64)pBaseRelocation + pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
					// calculates the delta of the two address
					DWORD64 BaseDelta = (DWORD64)((DWORD64)hModule - pNtHeaders->OptionalHeader.ImageBase);
					// while a virtual address exists
					while (BaseRelocationBlock != EndAddress)
					{
						// if this is a base relocation block
						if (BaseRelocationBlock->SizeOfBlock >= sizeof(IMAGE_BASE_RELOCATION))
						{
							// calculates the amount of relocations
							INT count = (BaseRelocationBlock->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
							// gets the first base relocation
							PWORD BaseRelocation = (PWORD)(BaseRelocationBlock + 1);
							// iterates through base relocations
							for (int i = 0; i < count; i++)
							{
								// if the base relation exists
								if (BaseRelocation[i])
								{
									// stores the address to offset
									DWORD64 Address;
									// gets the address to offset
									if (!ReadProcessMemory(hProcess, (PVOID)((DWORD64)hModule + (BaseRelocationBlock->VirtualAddress + (BaseRelocation[i] & 0xFFF))), &Address, sizeof(DWORD64), NULL))
									{
										// frees the buffer
										free(pBaseRelocation);
										// function failed
										return FALSE;
									}
									// offsets the address
									Address += BaseDelta;
									// writes the address back to the process
									if (!WriteProcessMemory(hProcess, (PVOID)((DWORD64)hModule + (BaseRelocationBlock->VirtualAddress + (BaseRelocation[i] & 0xFFF))), &Address, sizeof(DWORD64), NULL))
									{
										// frees the buffer
										free(pBaseRelocation);
										// function failed
										return FALSE;
									}
								}
							}
						}
						// gets the next base relocation block
						BaseRelocationBlock = (PIMAGE_BASE_RELOCATION)((DWORD64)BaseRelocationBlock + BaseRelocationBlock->SizeOfBlock);
					}
					// frees the buffer
					free(pBaseRelocation);
					// function suceeded
					return TRUE;
				}
				// frees the buffer
				free(pBaseRelocation);
				// function failed
				return FALSE;
			}
			// function failed
			return TRUE;
		}
		// function failed
		return FALSE;
	}

	// rebases the specified remote image (32 bit processes only)
	BOOL RemoteRebaseImage32(HANDLE hProcess, HMODULE hModule)
	{
		// reads the nt headers of the module
		if (PIMAGE_NT_HEADERS32 pNtHeaders = ReadNtHeaders32(hProcess, hModule))
		{
			// if the base relocation directory exists
			if (pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress)
			{
				// stores the base relocation directory
				PVOID pBaseRelocation = malloc(pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
				// reads the base relocation directory of the module
				if (ReadProcessMemory(hProcess, (PVOID)((DWORD64)hModule + pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress), pBaseRelocation, pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size, NULL))
				{
					// casts the buffer
					PIMAGE_BASE_RELOCATION BaseRelocationBlock = (PIMAGE_BASE_RELOCATION)pBaseRelocation;
					// calculates ending address
					PVOID EndAddress = (PVOID)((DWORD64)pBaseRelocation + pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
					// calculates the delta of the two address
					DWORD64 BaseDelta = (DWORD64)((DWORD64)hModule - pNtHeaders->OptionalHeader.ImageBase);
					// while a virtual address exists
					while (BaseRelocationBlock != EndAddress)
					{
						// if this is a base relocation block
						if (BaseRelocationBlock->SizeOfBlock >= sizeof(IMAGE_BASE_RELOCATION))
						{
							// calculates the amount of relocations
							INT count = (BaseRelocationBlock->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
							// gets the first base relocation
							PWORD BaseRelocation = (PWORD)(BaseRelocationBlock + 1);
							// iterates through base relocations
							for (int i = 0; i < count; i++)
							{
								// if the base relation exists
								if (BaseRelocation[i])
								{
									// stores the address to offset
									DWORD Address;
									// gets the address to offset
									if (!ReadProcessMemory(hProcess, (PVOID)((DWORD64)hModule + (BaseRelocationBlock->VirtualAddress + (BaseRelocation[i] & 0xFFF))), &Address, sizeof(DWORD), NULL))
									{
										// frees the buffer
										free(pBaseRelocation);
										// function failed
										return FALSE;
									}
									// offsets the address
									Address += BaseDelta;
									// writes the address back to the process
									if (!WriteProcessMemory(hProcess, (PVOID)((DWORD64)hModule + (BaseRelocationBlock->VirtualAddress + (BaseRelocation[i] & 0xFFF))), &Address, sizeof(DWORD), NULL))
									{
										// frees the buffer
										free(pBaseRelocation);
										// function failed
										return FALSE;
									}
								}
							}
						}
						// gets the next base relocation block
						BaseRelocationBlock = (PIMAGE_BASE_RELOCATION)((DWORD64)BaseRelocationBlock + BaseRelocationBlock->SizeOfBlock);
					}
					// frees the buffer
					free(pBaseRelocation);
					// function suceeded
					return TRUE;
				}
				// frees the buffer
				free(pBaseRelocation);
				// function failed
				return FALSE;
			}
			// function failed
			return TRUE;
		}
		// function failed
		return FALSE;
	}
	
	// rebases the specified remote image (universal wrapper)
	BOOL RemoteRebaseImage(HANDLE hProcess, HMODULE hModule)
	{
		// stores the result
		BOOL IsWow64;
		// checks the if the target process is 32 bit
		if (Process::IsProcess32(hProcess, &IsWow64))
			// checks if the process is 32 bit
			if (IsWow64)
				// returns the result
				return RemoteRebaseImage32(hProcess, hModule);
			else
				// returns the result
				return RemoteRebaseImage64(hProcess, hModule);
		// function failed
		return FALSE;
	}

	// remotely resolves the image imports (64 bit processes only)
	BOOL RemoteResolveImageImports64(HANDLE hProcess, HMODULE hModule)
	{
		// stores the import directory size
		DWORD dwSize;
		// reads the import directory
		if (PIMAGE_IMPORT_DESCRIPTOR pImportBlock = (PIMAGE_IMPORT_DESCRIPTOR)ReadDirectory(hProcess, hModule, IMAGE_DIRECTORY_ENTRY_IMPORT, &dwSize))
		{
			// iterates through import blocks
			while (pImportBlock->Characteristics)
			{
				// gets the module name length
				// DWORD dwNameLength = Process::GetRemoteStringLength(hProcess, (PVOID)((DWORD64)hModule + pImportBlock->Name));
				// stores the module name
				LPCSTR lpModule = new CHAR[MAX_PATH];
				// reads the module's name from the process
				if (!ReadProcessMemory(hProcess, (PVOID)((DWORD64)hModule + pImportBlock->Name), (PVOID)lpModule, MAX_PATH, NULL))
				{
					// function failed
					return FALSE;
				}
				// finds the dll path
				if (LPCSTR lpPath = File::FindImagePath64(ResolveApiModule(lpModule)))
				{
					// maps the module to the process
					if (HMODULE hTarget = LoadRemoteImage(hProcess, lpPath))
					{
						// gets the original first thunk address
						PVOID pOriginalFirstThunk = (PVOID)((DWORD64)hModule + pImportBlock->OriginalFirstThunk);
						// stores the original first thunk
						IMAGE_THUNK_DATA64 OriginalFirstThunk;
						// reads the original first thunk
						if (!ReadProcessMemory(hProcess, pOriginalFirstThunk, &OriginalFirstThunk, sizeof(IMAGE_THUNK_DATA64), NULL))
						{
							// function failed
							return FALSE;
						}
						// gets the original first thunk address
						PVOID pFirstThunk = (PVOID)((DWORD64)hModule + pImportBlock->FirstThunk);
						// stores the first thunk
						// IMAGE_THUNK_DATA FirstThunk;
						// while there is data
						while (OriginalFirstThunk.u1.AddressOfData)
						{
							// if it's an ordinal import
							if (OriginalFirstThunk.u1.Ordinal & IMAGE_ORDINAL_FLAG64)
							{
								// gets the ordinal
								DWORD64 Ordinal = (OriginalFirstThunk.u1.Ordinal & 0xFFFF);
								// resolve ordinal
								// gets the function address
								PVOID pFunction;
								// writes the function address
								if (!WriteProcessMemory(hProcess, pFirstThunk, &pFunction, sizeof(PVOID), NULL))
								{
									// function failed
									return FALSE;
								}
							}
							// if it's a name import
							else
							{
								// stores the function name
								LPCSTR lpFunction = new CHAR[MAX_PATH];
								// reads the function name
								if (!ReadProcessMemory(hProcess, (PVOID)((DWORD64)hModule + OriginalFirstThunk.u1.AddressOfData + sizeof(WORD)), (PVOID)lpFunction, MAX_PATH, NULL))
								{
									// function failed
									return FALSE;
								}
								// gets the function address
								PVOID pFunction = ResolveCrtModule64(hProcess, lpPath, reinterpret_cast<char *>(GetRemoteProcAddress(hProcess, hTarget, lpFunction)));
								// writes the function address
								if (!WriteProcessMemory(hProcess, pFirstThunk, &pFunction, sizeof(PVOID), NULL))
								{
									// function failed
									return FALSE;
								}
							}
							// gets the next original first thunk
							pOriginalFirstThunk = (PBYTE)pOriginalFirstThunk + sizeof(IMAGE_THUNK_DATA64);
							// reads the original first thunk
							if (!ReadProcessMemory(hProcess, pOriginalFirstThunk, &OriginalFirstThunk, sizeof(IMAGE_THUNK_DATA64), NULL))
							{
								// function failed
								return FALSE;
							}
							// gets the next first thunk
							pFirstThunk = (PBYTE)pFirstThunk + sizeof(IMAGE_THUNK_DATA64);
						}
					}
					else
					{
						// function failed
						return FALSE;
					}
				}
				else
				{
					// function failed
					return FALSE;
				}
				// gets the next import block
				pImportBlock++;
			}
			// function succeeded
			return TRUE;
		}
		// function failed
		return TRUE;
	}

	// remotely resolves the image imports (32 bit processes only)
	BOOL RemoteResolveImageImports32(HANDLE hProcess, HMODULE hModule)
	{
		// stores the import directory size
		DWORD dwSize;
		// reads the import directory
		if (PIMAGE_IMPORT_DESCRIPTOR pImportBlock = (PIMAGE_IMPORT_DESCRIPTOR)ReadDirectory(hProcess, hModule, IMAGE_DIRECTORY_ENTRY_IMPORT, &dwSize))
		{
			// iterates through import blocks
			while (pImportBlock->Characteristics)
			{
				// gets the module name length
				// DWORD dwNameLength = Process::GetRemoteStringLength(hProcess, (PVOID)((DWORD64)hModule + pImportBlock->Name));
				// stores the module name
				LPCSTR lpModule = new CHAR[MAX_PATH];
				// reads the module's name from the process
				if (!ReadProcessMemory(hProcess, (PVOID)((DWORD64)hModule + pImportBlock->Name), (PVOID)lpModule, MAX_PATH, NULL))
				{
					// function failed
					return FALSE;
				}
				// finds the dll path
				if (LPCSTR lpPath = File::FindImagePath32(ResolveApiModule(lpModule)))
				{
					// maps the module to the process
					if (HMODULE hTarget = LoadRemoteImage(hProcess, lpPath))
					{
						// gets the original first thunk address
						PVOID pOriginalFirstThunk = (PVOID)((DWORD64)hModule + pImportBlock->OriginalFirstThunk);
						// stores the original first thunk
						IMAGE_THUNK_DATA32 OriginalFirstThunk;
						// reads the original first thunk
						if (!ReadProcessMemory(hProcess, pOriginalFirstThunk, &OriginalFirstThunk, sizeof(IMAGE_THUNK_DATA32), NULL))
						{
							// function failed
							return FALSE;
						}
						// gets the original first thunk address
						PVOID pFirstThunk = (PVOID)((DWORD64)hModule + pImportBlock->FirstThunk);
						// stores the first thunk
						// IMAGE_THUNK_DATA FirstThunk;
						// while there is data
						while (OriginalFirstThunk.u1.AddressOfData)
						{
							// if it's an ordinal import
							if (OriginalFirstThunk.u1.Ordinal & IMAGE_ORDINAL_FLAG32)
							{
								// gets the ordinal
								DWORD64 Ordinal = (OriginalFirstThunk.u1.Ordinal & 0xFFFF);
								// resolve ordinal
								// gets the function address
								PVOID pFunction;
								// writes the function address
								if (!WriteProcessMemory(hProcess, pFirstThunk, &pFunction, sizeof(PVOID), NULL))
								{
									// function failed
									return FALSE;
								}
							}
							// if it's a name import
							else
							{
								// stores the funcion name
								LPCSTR lpFunction = new CHAR[MAX_PATH];
								// reads the function name
								if (!ReadProcessMemory(hProcess, (PVOID)((DWORD64)hModule + OriginalFirstThunk.u1.AddressOfData + sizeof(WORD)), (PVOID)lpFunction, MAX_PATH, NULL))
								{
									// function failed
									return FALSE;
								}
								// gets the function address
								PVOID pFunction = ResolveCrtModule32(hProcess, lpPath, reinterpret_cast<char *>(GetRemoteProcAddress(hProcess, hTarget, lpFunction)));
								// writes the function address
								if (!WriteProcessMemory(hProcess, pFirstThunk, &pFunction, sizeof(PVOID), NULL))
								{
									// function failed
									return FALSE;
								}
							}
							// gets the next original first thunk
							pOriginalFirstThunk = (PBYTE)pOriginalFirstThunk + sizeof(IMAGE_THUNK_DATA32);
							// reads the original first thunk
							if (!ReadProcessMemory(hProcess, pOriginalFirstThunk, &OriginalFirstThunk, sizeof(IMAGE_THUNK_DATA32), NULL))
							{
								// function failed
								return FALSE;
							}
							// gets the next first thunk
							pFirstThunk = (PBYTE)pFirstThunk + sizeof(IMAGE_THUNK_DATA32);
						}
					}
					else
					{
						// function failed
						return FALSE;
					}
				}
				else
				{
					// function failed
					return FALSE;
				}
				// gets the next import block
				pImportBlock++;
			}
			// function succeeded
			return TRUE;
		}
		// function failed
		return TRUE;
	}

	// remotely resolves the image imports (universal wrapper)
	BOOL RemoteResolveImageImports(HANDLE hProcess, HMODULE hModule)
	{
		// stores the result
		BOOL IsWow64;
		// checks the if the target process is 32 bit
		if (Process::IsProcess32(hProcess, &IsWow64))
			// checks if the process is 32 bit
			if (IsWow64)
				// returns the result
				return RemoteResolveImageImports32(hProcess, hModule);
			else
				// returns the result
				return RemoteResolveImageImports64(hProcess, hModule);
		// function failed
		return FALSE;
	}

	// gets the address of a procedure within the given process module by remotely parsing the export table (64 bit processes only)
	PVOID GetRemoteProcAddress64(HANDLE hProcess, HMODULE hModule, LPCSTR lpProcName)
	{
		// reads the nt headers of the module
		if (PIMAGE_NT_HEADERS64 pNtHeaders = ReadNtHeaders64(hProcess, hModule))
		{
			// if the export directory exists
			if (pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress)
			{
				// stores the export directory
				IMAGE_EXPORT_DIRECTORY ExportDirectory;
				// reads the export directory of the module
				if (ReadProcessMemory(hProcess, (PVOID)((DWORD64)hModule + pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress), &ExportDirectory, sizeof(IMAGE_EXPORT_DIRECTORY), NULL))
				{
					// stores the functions array
					PDWORD pFunctions = new DWORD[ExportDirectory.NumberOfFunctions];
					// reads the functions array
					if (ReadProcessMemory(hProcess, (PVOID)((DWORD64)hModule + ExportDirectory.AddressOfFunctions), pFunctions, ExportDirectory.NumberOfFunctions * sizeof(DWORD), NULL))
					{
						// stores the names array
						PDWORD pNames = new DWORD[ExportDirectory.NumberOfNames];
						// reads the names array
						if (ReadProcessMemory(hProcess, (PVOID)((DWORD64)hModule + ExportDirectory.AddressOfNames), pNames, ExportDirectory.NumberOfNames * sizeof(DWORD), NULL))
						{
							// stores the ordinals array
							PWORD pOrdinals = new WORD[ExportDirectory.NumberOfFunctions];
							// reads the ordinals array
							if (ReadProcessMemory(hProcess, (PVOID)((DWORD64)hModule + ExportDirectory.AddressOfNameOrdinals), pOrdinals, ExportDirectory.NumberOfFunctions * sizeof(WORD), NULL))
							{
								// iterates through function names
								for (int i = 0; i < ExportDirectory.NumberOfNames; i++)
								{
									// stores the function name
									CHAR lpFunctionName[MAX_PATH];
									// reads the function name
									if (ReadProcessMemory(hProcess, (PVOID)((DWORD64)hModule + pNames[i]), &lpFunctionName, MAX_PATH, NULL))
									{
										// compares the function names
										if (_stricmp(lpProcName, lpFunctionName) == 0)
										{
											// gets the function address
											PVOID pFunction = (PVOID)((DWORD64)hModule + pFunctions[pOrdinals[i]]);
											// cleans up the heap to prevent memory leaks
											// deletes the ordinals array
											delete pOrdinals;
											// deletes the names array
											delete pNames;
											// deletes the functions array
											delete pFunctions;
											// returns the address
											return pFunction;
										}
									}
								}
							}
							// deletes the ordinals array
							delete pOrdinals;
						}
						// deletes the names array
						delete pNames;
					}
					// deletes the functions array
					delete pFunctions;
				}
			}
		}
		// function failed
		return NULL;
	}

	// gets the address of a procedure within the given process module by remotely parsing the export table (32 bit processes only)
	PVOID GetRemoteProcAddress32(HANDLE hProcess, HMODULE hModule, LPCSTR lpProcName)
	{
		// reads the nt headers of the module
		if (PIMAGE_NT_HEADERS32 pNtHeaders = ReadNtHeaders32(hProcess, hModule))
		{
			// if the export directory exists
			if (pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress)
			{
				// stores the export directory
				IMAGE_EXPORT_DIRECTORY ExportDirectory;
				// reads the export directory of the module
				if (ReadProcessMemory(hProcess, (PVOID)((DWORD64)hModule + pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress), &ExportDirectory, sizeof(IMAGE_EXPORT_DIRECTORY), NULL))
				{
					// stores the functions array
					PDWORD pFunctions = new DWORD[ExportDirectory.NumberOfFunctions];
					// reads the functions array
					if (ReadProcessMemory(hProcess, (PVOID)((DWORD64)hModule + ExportDirectory.AddressOfFunctions), pFunctions, ExportDirectory.NumberOfFunctions * sizeof(DWORD), NULL))
					{
						// stores the names array
						PDWORD pNames = new DWORD[ExportDirectory.NumberOfNames];
						// reads the names array
						if (ReadProcessMemory(hProcess, (PVOID)((DWORD64)hModule + ExportDirectory.AddressOfNames), pNames, ExportDirectory.NumberOfNames * sizeof(DWORD), NULL))
						{
							// stores the ordinals array
							PWORD pOrdinals = new WORD[ExportDirectory.NumberOfFunctions];
							// reads the ordinals array
							if (ReadProcessMemory(hProcess, (PVOID)((DWORD64)hModule + ExportDirectory.AddressOfNameOrdinals), pOrdinals, ExportDirectory.NumberOfFunctions * sizeof(WORD), NULL))
							{
								// iterates through function names
								for (int i = 0; i < ExportDirectory.NumberOfNames; i++)
								{
									// gets the function name length
									// DWORD dwNameLength = Process::GetRemoteStringLength(hProcess, (PVOID)((DWORD64)hModule + pNames[i]));
									// stores the function name
									CHAR lpFunctionName[MAX_PATH];
									// reads the function name
									if (ReadProcessMemory(hProcess, (PVOID)((DWORD64)hModule + pNames[i]), &lpFunctionName, MAX_PATH, NULL))
									{
										// compares the function names
										if (_stricmp(lpProcName, lpFunctionName) == 0)
										{
											// gets the function address
											PVOID pFunction = (PVOID)((DWORD64)hModule + pFunctions[pOrdinals[i]]);
											// cleans up the heap to prevent memory leaks
											// deletes the ordinals array
											delete pOrdinals;
											// deletes the names array
											delete pNames;
											// deletes the functions array
											delete pFunctions;
											// returns the address
											return pFunction;
										}
									}
								}
							}
							// deletes the ordinals array
							delete pOrdinals;
						}
						// deletes the names array
						delete pNames;
					}
					// deletes the functions array
					delete pFunctions;
				}
			}
		}
		// function failed
		return NULL;
	}

	// gets the address of a procedure within the given process module by remotely parsing the export table (universal wrapper)
	PVOID GetRemoteProcAddress(HANDLE hProcess, HMODULE hModule, LPCSTR lpProcName)
	{
		// stores the result
		BOOL IsWow64;
		// checks the if the target process is 32 bit
		if (Process::IsProcess32(hProcess, &IsWow64))
			// checks if the process is 32 bit
			if (IsWow64)
				// returns the result
				return GetRemoteProcAddress32(hProcess, hModule, lpProcName);
			else
				// returns the result
				return GetRemoteProcAddress64(hProcess, hModule, lpProcName);
		// function failed
		return NULL;
	}

	// remotely loads a libaray via manual map
	HMODULE LoadRemoteImage(HANDLE hProcess, LPCSTR lpPath)
	{
		// gets the dll base name
		// LPCSTR lpBaseName = File::GetBaseName(lpPath);
		// resolves the api dll if need be
		// ResolveApiModule(lpBaseName);
		// attempts to get the module from the target process (checks our internel list of mapped modules also)
		HMODULE hModule = Module::GetRemoteModuleHandle(hProcess, File::GetBaseName(lpPath));
		// checks if the module is already loaded
		if (hModule)
			// returns the module handle
			return hModule;
		// remotely maps the image to the process
		if (hModule = RemoteMapImage(hProcess, lpPath))
			// rebases the remote image
			if (RemoteRebaseImage(hProcess, hModule))
				// resolves the image imports
				if (RemoteResolveImageImports(hProcess, hModule))
				{
					modules.push_back({ File::GetBaseName(lpPath), hModule });
					// return the module handle
					return hModule;
				}
		// function failed
		return NULL;
	}

	// remotely loads a library into the process associated with the given process handle (64 bit processes only)
	HMODULE LoadRemoteLibrary64(HANDLE hProcess, LPCSTR lpPath)
	{
		// manually maps the dll
		if (HMODULE hModule = LoadRemoteImage(hProcess, lpPath))
		{
			// reads the nt headers
			if (PIMAGE_NT_HEADERS64 pNtHeaders = ReadNtHeaders64(hProcess, hModule))
			{
				// calculates the entry point
				PVOID pEntry = (PBYTE)hModule + pNtHeaders->OptionalHeader.AddressOfEntryPoint;
				// creates a thread that calls load library with our dll path
				if (Thread::CallEntry(hProcess, pEntry, hModule, DLL_PROCESS_ATTACH))
				{
					// returns the module handle
					return hModule;
				}
			}
		}
		// returns false
		return NULL;
	}

	// remotely loads a library into the process associated with the given process handle (32 bit processes only)
	HMODULE LoadRemoteLibrary32(HANDLE hProcess, LPCSTR lpPath)
	{
		// manually maps the dll
		if (HMODULE hModule = LoadRemoteImage(hProcess, lpPath))
		{
			// reads the nt headers
			if (PIMAGE_NT_HEADERS32 pNtHeaders = ReadNtHeaders32(hProcess, hModule))
			{
				// calculates the entry point
				PVOID pEntry = (PBYTE)hModule + pNtHeaders->OptionalHeader.AddressOfEntryPoint;
				// creates a thread that calls load library with our dll path
				if (Thread::CallEntry(hProcess, pEntry, hModule, DLL_PROCESS_ATTACH))
				{
					// returns the module handle
					return hModule;
				}
			}
		}
		// returns false
		return NULL;
	}

	// remotely loads a library into the process associated with the given process handle (universal wrapper)
	HMODULE LoadRemoteLibrary(HANDLE hProcess, LPCSTR lpPath)
	{
		// stores the result
		BOOL IsWow64;
		// checks the if the target process is 32 bit
		if (Process::IsProcess32(hProcess, &IsWow64))
			// checks if the process is 32 bit
			if (IsWow64)
				// returns the result
				return LoadRemoteLibrary32(hProcess, lpPath);
			else
				// returns the result
				return LoadRemoteLibrary64(hProcess, lpPath);
		// function failed
		return NULL;
	}

	// remotely loads a libaray via load library
	BOOL LoadLibraryRemote(HANDLE hProcess, LPCSTR lpPath)
	{
		// gets a random thread id from the process
		if (DWORD dwThreadId = Thread::GetProcessThread(GetProcessId(hProcess)))
		{
			// opens a handle to the thread
			if (HANDLE hThread = Thread::GetThreadHandle(dwThreadId, THREAD_ALL_ACCESS))
			{
				// allocates memory for the dll path in the target process
				if (LPVOID pPath = VirtualAllocEx(hProcess, 0, strlen(lpPath) + 1, MEM_COMMIT, PAGE_READWRITE))
				{
					// writes the path to the process
					if (WriteProcessMemory(hProcess, pPath, (LPVOID)lpPath, strlen(lpPath) + 1, 0))
					{
						// opens the externel module
						if (HMODULE hModule = GetRemoteModuleHandle(hProcess, "Kernel32.dll"))
						{
							// gets the address of load library
							if (PVOID pLoadLibrary = GetRemoteProcAddress(hProcess, hModule, "LoadLibraryA"))
							{
								// creates a thread that calls load library with our dll path
								if (Thread::RedirectThread(hProcess, hThread, pLoadLibrary, pPath))
								{
									// closes the thread handle
									CloseHandle(hThread);
									// returns true
									return TRUE;
								}
							}
						}
					}
				}
				// closes the thread handle
				CloseHandle(hThread);
			}
		}
		// returns false
		return FALSE;
	}
}

// rewrite FindImagePath64
// create FindImagePath32
// rewrite ResolveApiModule
// iternel linked list of mapped modules (hProcess, hModule, lpModule) checked in GetRemoteModuleHandle
// add GetRemoteStringLength to functions
// add ReadDirectory to corrosponding functions
// ManualMapRemote should resolve the dll name passed into it (check if it's just a basename and then find it's corrosponding dll and path)
// add ordinal GetRemoteProcAddress function

// write 64 bit shellcode

// potnetially add callentry point to modules namespace instead

// process() class

// user32 rebasing problem

// Parse handle tables