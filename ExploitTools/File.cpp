#include "Tools.h"

// various tools used to interact with file objects
namespace File
{
	// returns the path of a 64 bit image on the system
	LPCSTR FindImagePath64(LPCSTR lpModuleName)
	{
		// stores the path
		CHAR CurrentDir[MAX_PATH];
		// checks if the dll is in the current directory
		GetCurrentDirectory(MAX_PATH, CurrentDir);
		// concatenates the strings
		strcat_s(CurrentDir, "\\");
		strcat_s(CurrentDir, lpModuleName);
		// checks if the file exists
		if (PathFileExists(CurrentDir))
		{
			// returns the path
			return (new std::string(CurrentDir))->c_str();
		}
		// stores the path
		CHAR SystemDir[MAX_PATH];
		// checks if the dll is in the current directory
		GetSystemDirectory(SystemDir, MAX_PATH);
		// concatenates the strings
		strcat_s(SystemDir, "\\");
		strcat_s(SystemDir, lpModuleName);
		// checks if the file exists
		if (PathFileExists(SystemDir))
		{
			// returns the path
			return (new std::string(SystemDir))->c_str();
		}
		// stores the path
		CHAR WindowsDir[MAX_PATH];
		// checks if the dll is in the current directory
		GetWindowsDirectory(WindowsDir, MAX_PATH);
		// concatenates the strings
		strcat_s(WindowsDir, "\\");
		strcat_s(WindowsDir, lpModuleName);
		// checks if the file exists
		if (PathFileExists(WindowsDir))
		{
			// returns the path
			return (new std::string(WindowsDir))->c_str();
		}
		// else we return null
		return NULL;
	}

	// returns the path of a 32 bit image on the system
	LPCSTR FindImagePath32(LPCSTR lpModuleName)
	{
		// stores the path
		CHAR CurrentDir[MAX_PATH];
		// checks if the dll is in the current directory
		GetCurrentDirectory(MAX_PATH, CurrentDir);
		// concatenates the strings
		strcat_s(CurrentDir, "\\");
		strcat_s(CurrentDir, lpModuleName);
		// checks if the file exists
		if (PathFileExists(CurrentDir))
		{
			// returns the path
			return (new std::string(CurrentDir))->c_str();
		}
		// stores the path
		CHAR SystemDir[MAX_PATH] = "C:\\Windows\\SysWOW64";
		// checks if the dll is in the current directory
		// GetSystemDirectory(SystemDir, MAX_PATH);
		// concatenates the strings
		strcat_s(SystemDir, "\\");
		strcat_s(SystemDir, lpModuleName);
		// checks if the file exists
		if (PathFileExists(SystemDir))
		{
			// returns the path
			return (new std::string(SystemDir))->c_str();
		}
		// stores the path
		CHAR WindowsDir[MAX_PATH];
		// checks if the dll is in the current directory
		GetWindowsDirectory(WindowsDir, MAX_PATH);
		// concatenates the strings
		strcat_s(WindowsDir, "\\");
		strcat_s(WindowsDir, lpModuleName);
		// checks if the file exists
		if (PathFileExists(WindowsDir))
		{
			// returns the path
			return (new std::string(WindowsDir))->c_str();
		}
		// else we return null
		return NULL;
	}

	// returns the basename of a path
	LPCSTR GetBaseName(LPCSTR lpPath)
	{
		// casts the char pointer to a standard string
		std::string Path(lpPath);
		// finds the last directory seperator
		size_t Index = Path.find_last_of("\\/");
		// validates the find
		if (Index != std::string::npos)
		{
			// gets the base name
			std::string* Basename = new std::string(Path.substr(Index + 1));
			// gets and returns the base name buffer
			return Basename->c_str();
		}
		// returns the original string
		return lpPath;
	}

	// creates the given path
	VOID CreatePath(LPCSTR lpPath)
	{
		// converts the char array to a standard string
		std::string Path(lpPath);
		// stores the current path
		std::string CurrentPath;
		// loops to create each directory
		while (TRUE)
		{
			// finds the directory seperator
			size_t index = Path.find("\\/");
			// validates the result
			if (index == std::string::npos)
				// interated thorugh all directories so we are done
				break;
			// adds the directory to the current path
			CurrentPath += Path.substr(0, index + 1);
			// increments the positing of path to the next directory
			Path.erase(Path.begin(), Path.begin() + index + 1);
			// creates the directory
			CreateDirectory(CurrentPath.c_str(), NULL);
		}
	}

	// reads the specified file into a buffer
	PVOID ReadW(LPCWSTR lpFile, PDWORD dwOut)
	{
		// opens the requested file
		HANDLE hFile = CreateFileW(lpFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		// validates the handle
		if (hFile != INVALID_HANDLE_VALUE)
		{
			// gets the file size
			DWORD dwSize = GetFileSize(hFile, NULL);
			// validates the file size
			if (dwSize != INVALID_FILE_SIZE)
			{
				// creates a buffer for the file
				PVOID pFile = malloc(dwSize);
				// validates the buffer
				if (pFile)
				{
					// stores the number of bytes read
					DWORD dwBytes;
					// reads the file into the buffer
					if (ReadFile(hFile, pFile, dwSize, &dwBytes, NULL) && dwBytes == dwSize)
					{
						// closes the file handle
						CloseHandle(hFile);
						// sets the output size
						*dwOut = dwSize;
						// funtion succeeded
						return pFile;
					}
					// frees the buffer
					VirtualFree(pFile, 0, MEM_RELEASE);
				}
			}
			// closes the file handle
			CloseHandle(hFile);
		}
		// function failed
		return FALSE;
	}

	// reads the specified file into a buffer
	PVOID ReadA(LPCSTR lpFile, PDWORD dwOut)
	{
		// opens the requested file
		HANDLE hFile = CreateFileA(lpFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		// validates the handle
		if (hFile != INVALID_HANDLE_VALUE)
		{
			// gets the file size
			DWORD dwSize = GetFileSize(hFile, NULL);
			// validates the file size
			if (dwSize != INVALID_FILE_SIZE)
			{
				// creates a buffer for the file
				PVOID pFile = malloc(dwSize);
				// validates the buffer
				if (pFile)
				{
					// stores the number of bytes read
					DWORD dwBytes;
					// reads the file into the buffer
					if (ReadFile(hFile, pFile, dwSize, &dwBytes, NULL) && dwBytes == dwSize)
					{
						// closes the file handle
						CloseHandle(hFile);
						// sets the output size
						*dwOut = dwSize;
						// funtion succeeded
						return pFile;
					}
					// frees the buffer
					VirtualFree(pFile, 0, MEM_RELEASE);
				}
			}
			// closes the file handle
			CloseHandle(hFile);
		}
		// function failed
		return FALSE;
	}

	// write the specified buffer and length to the disk
	BOOL WriteA(LPCSTR lpFile, PVOID pBuffer, DWORD dwSize)
	{
		// creates the path
		CreatePath(lpFile);
		// creates the requested file
		HANDLE hFile = CreateFileA(lpFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		// validates the handle
		if (hFile != INVALID_HANDLE_VALUE)
		{
			// stores the n umber of bytes written
			DWORD dwBytes;
			// writes the data to the file
			if (WriteFile(hFile, pBuffer, dwSize, &dwBytes, NULL) && dwBytes == dwSize)
			{
				// closes the file handle
				CloseHandle(hFile);
				// function succeeded
				return TRUE;
			}
		}
		// function failed
		return FALSE;
	}

	// write the specified buffer and length to the disk
	BOOL WriteW(LPCWSTR lpFile, PVOID pBuffer, DWORD dwSize)
	{
		// creates the requested file
		HANDLE hFile = CreateFileW(lpFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		// validates the handle
		if (hFile != INVALID_HANDLE_VALUE)
		{
			// stores the n umber of bytes written
			DWORD dwBytes;
			// writes the data to the file
			if (WriteFile(hFile, pBuffer, dwSize, &dwBytes, NULL) && dwBytes == dwSize)
			{
				// closes the file handle
				CloseHandle(hFile);
				// function succeeded
				return TRUE;
			}
		}
		// function failed
		return FALSE;
	}
}