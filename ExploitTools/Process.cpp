#include "Tools.h"

// various tools used to interact with process objects
namespace Process
{
	// returns the length of a remote string
	DWORD GetRemoteStringLength(HANDLE hProcess, PVOID pString)
	{
		// stores the character
		CHAR Character;
		// defines the string index
		DWORD dwIndex = 0;
		// while the character is not zero
		do
		{
			// reads a character
			if (!ReadProcessMemory(hProcess, (PBYTE)pString + dwIndex, &Character, sizeof(CHAR), NULL))
				// function failed
				return NULL;
			// increments the index
			dwIndex += 1;
		} while (Character != 0);
		// returns the string length
		return dwIndex;
	}

	// wrapper for iswow64process
	BOOL IsProcess32(HANDLE hProcess, PBOOL Wow64Process)
	{
		// checks if the function exists
		if (GetProcAddress(GetModuleHandleA("Kernel32.dll"), "IsWow64Process"))
			// checks the if the target process is running under wow64
			if (IsWow64Process(hProcess, Wow64Process))
				// function succeeded
				return TRUE;
		// returns false
		return FALSE;
	}

	// returns the process id for the given image name
	DWORD FindProcess(LPCSTR lpImageName)
	{
		// enables the debug priviliage
		SetDebugPrivilege(GetCurrentProcess(), TRUE);
		// gets a snapshot of the system processes
		HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
		// validates the handle
		if (hSnapshot != INVALID_HANDLE_VALUE)
		{
			// stores the process information
			PROCESSENTRY32 ProcessInfo;
			// sets the structure size
			ProcessInfo.dwSize = sizeof(PROCESSENTRY32);
			// gets the first process
			if (Process32First(hSnapshot, &ProcessInfo))
			{
				// gets the information of the next process
				do
				{
					// checks the process name
					if (_stricmp(ProcessInfo.szExeFile, lpImageName) == 0)
					{
						// disables the debug priviliage
						SetDebugPrivilege(GetCurrentProcess(), FALSE);
						// returns the pid
						return ProcessInfo.th32ProcessID;
					}
				} while (Process32Next(hSnapshot, &ProcessInfo));
			}
		}
		// disables the debug priviliage
		SetDebugPrivilege(GetCurrentProcess(), FALSE);
		// else we return null
		return NULL;
	}

	// returns the eprocess address for the process id given
	// using the ntquerysysteminformation eprocess address leak
	PVOID GetObjectAddress(DWORD dwProcessId)
	{
		// opens a handle to the process
		HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, dwProcessId);
		// validates the handle
		if (hProcess != INVALID_HANDLE_VALUE)
		{
			// allocates a buffer to store the retrieved handle information
			PSYSTEM_HANDLE_INFORMATION pHandles = (PSYSTEM_HANDLE_INFORMATION)malloc(10000);
			// stores the return length
			ULONG uLength = 10000;
			// zeros out the buffer
			ZeroMemory(pHandles, 10000);
			// queries all the handles on the system
			while (NtQuerySystemInformation(SystemHandleInformation, pHandles, uLength, &uLength) == STATUS_INFO_LENGTH_MISMATCH)
			{
				// reallocates the buffer to the correct size
				pHandles = (PSYSTEM_HANDLE_INFORMATION)realloc(pHandles, uLength);
				// zeros out the buffer
				ZeroMemory(pHandles, uLength);
			}
			// iterates through system handles
			for (int i = 0; i < pHandles->HandleCount; i++)
			{
				// checks the process id and the handle value
				if (pHandles->Handles[i].ProcessId == GetCurrentProcessId() && pHandles->Handles[i].Handle == (USHORT)hProcess)
				{
					// closes the handle
					CloseHandle(hProcess);
					// returns the address of the eprocess object
					return pHandles->Handles[i].Object;
				}
			}
			// closes the handle
			CloseHandle(hProcess);
		}
		// else we return null
		return NULL;
	}

	// sets the handle's granted access value
	BOOL SetHandleAccess(HANDLE hProcess, DWORD DesiredAccess)
	{
		// make driver static functions
		// creates our driver object
		Driver KernelDriver = Driver();
		// loads the kernel driver
		if (KernelDriver.LoadDriver())
		{
			// elevates the handle with the kernel driver
			if (KernelDriver.SetHandleAccess(GetCurrentProcessId(), hProcess, DesiredAccess))
			{
				// unloads the kernel driver
				if (KernelDriver.UnloadDriver())
				{
					// we return true
					return TRUE;
				}
			}
			// unloads the kernel driver
			KernelDriver.UnloadDriver();
		}
		// else we return false
		return FALSE;
	}

	// opens a handle to the given process via a driver
	HANDLE GetProcessHandle(DWORD dwProcessId, DWORD dwDesiredAccess)
	{
		// opens a handle to the process
		HANDLE hProcess = OpenProcess(dwDesiredAccess, FALSE, dwProcessId);
		// validates the handle
		if (hProcess != INVALID_HANDLE_VALUE)
			// check if the handle value is correct
			// if not elevate
			// do this!
			// elevates the created handle
			// if (SetHandleAccess(hProcess, dwDesiredAccess))
			// returns the handle
			return hProcess;
		// function failed
		return NULL;
	}

	// enables or disables the given priviliage for the given process
	BOOL SetPrivilege(HANDLE hProcess, LPCTSTR lpPrivilege, BOOL Enable)
	{
		// stores the privilege token
		TOKEN_PRIVILEGES Token;
		// stores the luid
		LUID Luid;
		// gets the requested privilage luid
		if (LookupPrivilegeValue(NULL, lpPrivilege, &Luid))
		{
			// set the amount of priviliages to change
			Token.PrivilegeCount = 1;
			// sets the privilage luid
			Token.Privileges[0].Luid = Luid;
			// enables the privilage
			if (Enable) Token.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
			// disables the privilage
			else Token.Privileges[0].Attributes = 0;
			// sets the requested privilage
			if (AdjustTokenPrivileges(hProcess, FALSE, &Token, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL) && GetLastError() != ERROR_NOT_ALL_ASSIGNED)
			{
				// function succeeded
				return TRUE;
			}
		}
		// function failed
		return FALSE;
	}

	// enables or disables the debug priviliage for the given process
	BOOL SetDebugPrivilege(HANDLE hProcess, BOOL Enable)
	{
		// sets the debug priviliage an returns the result
		return SetPrivilege(hProcess, SE_DEBUG_NAME, Enable);
	}

	// scans the process memory for a particular value
	BOOL ScanBuffer(HANDLE hProcess, PBYTE pSource, DWORD dwSourceLength, PBYTE pTarget, DWORD dwTargetLength)
	{
		// gets the memory upper bound address
		PBYTE pBoundAddress = pSource + dwSourceLength;
		// iterates through the memory pages
		while (pSource < pBoundAddress)
		{
			// stores the memory information
			MEMORY_BASIC_INFORMATION MemoryInformation;
			// determines if it is a memory page
			if (!VirtualQueryEx(hProcess, pSource, &MemoryInformation, sizeof(MEMORY_BASIC_INFORMATION))) return FALSE;
			// validates the memory protections and state in order to avoid exceptions
			if ((MemoryInformation.State == MEM_COMMIT) && (MemoryInformation.Protect & (PAGE_READONLY | PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)) && !(MemoryInformation.Protect & PAGE_GUARD))
			{
				// creates a buffer to store the memory page
				PVOID pBuffer = VirtualAllocEx(hProcess, NULL, MemoryInformation.RegionSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
				// reads the memory page into our process
				if (ReadProcessMemory(hProcess, pSource, pBuffer, MemoryInformation.RegionSize, NULL))
				{
					// scans the buffer for the value
					Memory::ScanBuffer((PBYTE)pBuffer, MemoryInformation.RegionSize, pTarget, dwTargetLength);
					// fixes the addresses
					// frees the buffer
					VirtualFree(pBuffer, 0, MEM_RELEASE);
				}
			}
			// gets the next memory page
			pSource += MemoryInformation.RegionSize;
		}
	}

	// sans a wholes programs virtual memory for the given value
	BOOL ScanMemory(HANDLE hProcess, PBYTE pTarget, DWORD dwTargetLength)
	{
		// stores the system information
		SYSTEM_INFO SystemInfo;
		// gets the system information in ordere to determine the process address space size
		GetNativeSystemInfo(&SystemInfo);
		// scans the whole process memory
		return ScanBuffer(hProcess, (PBYTE)SystemInfo.lpMinimumApplicationAddress, 0, pTarget, dwTargetLength);
	}
}